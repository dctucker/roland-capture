diff --git a/sound/usb/Makefile b/sound/usb/Makefile
index 9ccb21a4ff8a..afc3ce1a4563 100644
--- a/sound/usb/Makefile
+++ b/sound/usb/Makefile
@@ -10,6 +10,7 @@ snd-usb-audio-objs := 	card.o \
 			helper.o \
 			implicit.o \
 			mixer.o \
+			mixer_capture.o \
 			mixer_quirks.o \
 			mixer_scarlett.o \
 			mixer_scarlett_gen2.o \
diff --git a/sound/usb/card.c b/sound/usb/card.c
index 0fff96a5d3ab..5946b595882a 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -835,6 +835,14 @@ static int usb_audio_probe(struct usb_interface *intf,
 		err = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);
 		if (err < 0)
 			goto __error;
+		pr_info("card.c audio probe quirk: %d", err);
+	}
+
+	if (chip->usb_id == USB_ID(0x0582, 0x0160)) {
+		err = snd_usb_create_mixer(chip, ifnum);
+		pr_info("quirk create capture mixer: %d", err);
+		if (err < 0)
+			goto __error;
 	}
 
 	if (err > 0) {
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index bbff0923d264..2688fe80cdbf 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -1686,6 +1686,9 @@ static struct port_info {
 	CONTROL_PORT(0x0582, 0x0120, 1, "%s Control"),
 	EXTERNAL_PORT(0x0582, 0x0121, 0, "%s MIDI"),
 	CONTROL_PORT(0x0582, 0x0121, 1, "%s Control"),
+	/* Roland STUDIO-CAPTURE */
+	EXTERNAL_PORT(0x0582, 0x0160, 0, "%s MIDI"),
+	CONTROL_PORT(0x0582, 0x0160, 1, "%s Control"),
 	/* Roland SPD-SX */
 	CONTROL_PORT(0x0582, 0x0145, 0, "%s Control"),
 	EXTERNAL_PORT(0x0582, 0x0145, 1, "%s MIDI"),
@@ -2117,6 +2120,7 @@ static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,
 	intf = umidi->iface;
 	if (!intf || intf->num_altsetting < 1)
 		return -ENOENT;
+
 	hostif = intf->cur_altsetting;
 	intfd = get_iface_desc(hostif);
 
@@ -2140,6 +2144,7 @@ static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi,
 			++in_eps;
 		}
 	}
+	pr_info("quirk out_eps: %d, in_eps: %d", out_eps, in_eps);
 	return (out_eps || in_eps) ? 0 : -ENOENT;
 }
 
@@ -2216,6 +2221,7 @@ static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,
 	if (!intf)
 		return -ENOENT;
 	hostif = intf->altsetting;
+
 	/*
 	 * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,
 	 * some have standard class descriptors, or both kinds, or neither.
@@ -2223,6 +2229,8 @@ static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,
 	for (cs_desc = hostif->extra;
 	     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;
 	     cs_desc += cs_desc[0]) {
+
+
 		if (cs_desc[0] >= 6 &&
 		    cs_desc[1] == USB_DT_CS_INTERFACE &&
 		    cs_desc[2] == 0xf1 &&
@@ -2231,6 +2239,8 @@ static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,
 				continue;
 			endpoint->in_cables  = (1 << cs_desc[4]) - 1;
 			endpoint->out_cables = (1 << cs_desc[5]) - 1;
+			// expect 06 24 f1 02 02 02
+			pr_info("quirk midi roland cables: %d/%d", endpoint->in_cables, endpoint->out_cables);
 			return snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
 		} else if (cs_desc[0] >= 7 &&
 			   cs_desc[1] == USB_DT_CS_INTERFACE &&
@@ -2368,6 +2378,9 @@ static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi,
 			    &snd_usbmidi_input_ops);
 
 	umidi->rmidi = rmidi;
+
+	pr_info("quirk create rawmidi");
+
 	return 0;
 }
 
diff --git a/sound/usb/mixer_capture.c b/sound/usb/mixer_capture.c
new file mode 100644
index 000000000000..78f2f7066290
--- /dev/null
+++ b/sound/usb/mixer_capture.c
@@ -0,0 +1,776 @@
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/usb/audio-v2.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/tlv.h>
+
+#include "usbaudio.h"
+#include "mixer.h"
+#include "helper.h"
+
+#include "mixer_capture.h"
+
+/* release elem->private_free as well; called only once for each *_store */
+static void elem_private_free(struct snd_kcontrol *kctl)
+{
+	struct usb_mixer_elem_info *elem = kctl->private_data;
+
+	if (elem)
+		kfree(elem->private_data);
+	kfree(elem);
+	kctl->private_data = NULL;
+}
+
+static int add_new_ctl(struct usb_mixer_interface *mixer,
+	const struct snd_kcontrol_new *ncontrol,
+	int index, int val_type, int channels,
+	const char *name, void *opt,
+	bool do_private_free,
+	struct usb_mixer_elem_info **elem_ret)
+{
+	struct snd_kcontrol *kctl;
+	struct usb_mixer_elem_info *elem;
+	int err;
+
+	usb_audio_dbg(mixer->chip, "roland-capture add mixer %s\n", name);
+
+	elem = kzalloc(sizeof(*elem), GFP_KERNEL);
+	if (!elem)
+		return -ENOMEM;
+
+	elem->head.mixer = mixer;
+	elem->head.resume = NULL;
+	elem->control = 0;
+	elem->idx_off = 0;
+	elem->head.id = index;
+	elem->val_type = val_type;
+	elem->channels = channels;
+	elem->private_data = opt;
+
+	kctl = snd_ctl_new1(ncontrol, elem);
+	if (!kctl) {
+		kfree(elem);
+		return -ENOMEM;
+	}
+
+	if (do_private_free)
+		kctl->private_free = elem_private_free;
+	else
+		kctl->private_free = snd_usb_mixer_elem_free;
+
+	strscpy(kctl->id.name, name, sizeof(kctl->id.name));
+
+	err = snd_usb_mixer_add_control(&elem->head, kctl);
+	if (err < 0)
+		return err;
+
+	if (elem_ret)
+		*elem_ret = elem;
+
+	return 0;
+}
+
+static int snd_capture_patchbay_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	int index = ucontrol->id.index;
+
+	/* patch has no bias */
+	ucontrol->value.enumerated.item[0] = elem->cache_val[index];
+
+	return 0;
+}
+static int snd_capture_patchbay_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	int index = ucontrol->id.index;
+	//char buf[sizeof(route_msg)];
+	int val, err;
+
+	/*  get the new value (no bias for routes) */
+	val = ucontrol->value.enumerated.item[0];
+
+	/* sanity check */
+	if (val < 0 || val > 8)
+		return -EINVAL;
+
+#if 0
+	/* prepare the message buffer from template */
+	memcpy(buf, route_msg, sizeof(route_msg));
+	...
+	err = snd_us16x08_send_urb(chip, buf, sizeof(route_msg));
+#endif
+	err = 1;
+
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set routing, err:%d\n", err);
+	}
+
+	return err > 0 ? 1 : 0;
+}
+static const char *patch_names[] = (const char *[]){
+	"MIX A", "MIX B", "MIX C", "MIX D",
+	"WAVE 1/2", "WAVE 3/4", "WAVE 5/6", "WAVE 7/8", "WAVE 9/10",
+};
+
+static int snd_capture_patchbay_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	return snd_ctl_enum_info(uinfo, 1, 9, patch_names);
+}
+static const struct snd_kcontrol_new snd_capture_patchbay_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.count = 5,
+	.info = snd_capture_patchbay_info,
+	.get = snd_capture_patchbay_get,
+	.put = snd_capture_patchbay_put,
+	.private_value = 0x30000,
+};
+
+static int snd_capture_switch_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int val;
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	//struct snd_us16x08_eq_store *store = elem->private_data;
+	int index = ucontrol->id.index;
+
+	val = elem->cache_val[index];
+	ucontrol->value.integer.value[0] = val;
+
+	return 0;
+}
+
+static int snd_capture_switch_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	//struct snd_us16x08_eq_store *store = elem->private_data;
+	int index = ucontrol->id.index;
+	//char buf[sizeof(eqs_msq)];
+	int val, err = 0;
+	//int b_idx;
+
+	val = ucontrol->value.integer.value[0];
+
+#if 0
+	/* prepare URB message from EQ template */
+	memcpy(buf, eqs_msq, sizeof(eqs_msq));
+
+	/* place channel index in URB message */
+	buf[5] = index + 1;
+	for (b_idx = 0; b_idx < SND_US16X08_ID_EQ_BAND_COUNT; b_idx++) {
+		/* all four EQ bands have to be enabled/disabled in once */
+		buf[20] = val;
+		buf[17] = store->val[b_idx][2][index];
+		buf[14] = store->val[b_idx][1][index];
+		buf[11] = store->val[b_idx][0][index];
+		buf[8] = b_idx + 1;
+		err = snd_us16x08_send_urb(chip, buf, sizeof(eqs_msq));
+		if (err < 0)
+			break;
+		store->val[b_idx][3][index] = val;
+		msleep(15);
+	}
+#endif
+
+	err = 1;
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set eq switch, err:%d\n", err);
+	}
+
+	return 1;
+}
+
+#define DECLARE_CAPTURE_SWITCH(addr, name, c) \
+struct snd_kcontrol_new snd_capture_##name##_ctl = { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.count = c, \
+	.info = snd_capture_switch_info, \
+	.get  = snd_capture_switch_get, \
+	.put  = snd_capture_switch_put, \
+	.private_value = addr, \
+}
+
+#define snd_capture_switch_info snd_ctl_boolean_mono_info
+static const DECLARE_CAPTURE_SWITCH(0x60000, stereo, 8);
+static const DECLARE_CAPTURE_SWITCH(0x60002, solo, 16);
+static const DECLARE_CAPTURE_SWITCH(0x60003, mute, 16);
+static const DECLARE_CAPTURE_SWITCH(0x70000, daw_stereo, 5);
+static const DECLARE_CAPTURE_SWITCH(0x70002, daw_solo, 10);
+static const DECLARE_CAPTURE_SWITCH(0x70003, daw_mute, 10);
+static const DECLARE_CAPTURE_SWITCH(0x50000, 48, 12);
+static const DECLARE_CAPTURE_SWITCH(0x50001, locut, 12);
+static const DECLARE_CAPTURE_SWITCH(0x50002, phase, 12);
+static const DECLARE_CAPTURE_SWITCH(0x50003, hiz, 2);
+static const DECLARE_CAPTURE_SWITCH(0x50006, bypass, 12);
+
+#if 0
+static const DECLARE_CAPTURE_SWITCH(0x50007, gate, 12);
+static const DECLARE_CAPTURE_SWITCH(0x50008, attack, 12);
+static const DECLARE_CAPTURE_SWITCH(0x50009, release, 12);
+static const DECLARE_CAPTURE_SWITCH(0x5000a, threshold, 12);
+static const DECLARE_CAPTURE_SWITCH(0x5000b, ratio, 12);
+static const DECLARE_CAPTURE_SWITCH(0x5000c, gain, 12);
+static const DECLARE_CAPTURE_SWITCH(0x5000d, knee, 12);
+#endif
+
+static int snd_capture_pan_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	int index = ucontrol->id.index;
+
+	ucontrol->value.integer.value[0] = elem->cache_val[index];
+
+	return 0;
+}
+
+static int snd_capture_pan_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	//char buf[sizeof(mix_msg_in)];
+	int val, err;
+	int index = ucontrol->id.index;
+
+	val = ucontrol->value.integer.value[0];
+
+#if 0
+	/* sanity check */
+	if (val < SND_US16X08_KCMIN(kcontrol)
+		|| val > SND_US16X08_KCMAX(kcontrol))
+		return -EINVAL;
+
+	/* prepare URB message from template */
+	memcpy(buf, mix_msg_in, sizeof(mix_msg_in));
+
+	/* add the bias to the new value */
+	buf[8] = val - SND_US16X08_KCBIAS(kcontrol);
+	buf[6] = elem->head.id;
+	buf[5] = index + 1;
+
+	err = snd_us16x08_send_urb(chip, buf, sizeof(mix_msg_in));
+#endif
+	err = 1;
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set channel, err:%d\n", err);
+	}
+
+	return err > 0 ? 1 : 0;
+}
+static int snd_capture_pan_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->count = 1;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.min = 0x0000;
+	uinfo->value.integer.max = 0x8000;
+	uinfo->value.integer.step = 0x4000 / 100;
+	return 0;
+}
+
+static const struct snd_kcontrol_new snd_capture_pan_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.count = 16,
+	.info = snd_capture_pan_info,
+	.get  = snd_capture_pan_get,
+	.put  = snd_capture_pan_put,
+	.private_value = 0x60004,
+};
+static const struct snd_kcontrol_new snd_capture_daw_pan_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.count = 10,
+	.info = snd_capture_pan_info,
+	.get  = snd_capture_pan_get,
+	.put  = snd_capture_pan_put,
+	.private_value = 0x70004,
+};
+
+static int snd_capture_volume_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	int index = ucontrol->id.index;
+
+	ucontrol->value.integer.value[0] = elem->cache_val[index];
+
+	return 0;
+}
+
+static int snd_capture_volume_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	int val, err;
+	int index = ucontrol->id.index;
+
+	val = ucontrol->value.integer.value[0];
+
+	err = 1;
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set channel, err:%d\n", err);
+	}
+
+	return err > 0 ? 1 : 0;
+}
+static int snd_capture_volume_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->count = 1;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.max = 0x800000;
+	uinfo->value.integer.min = 0x000000;
+	//uinfo->value.integer.step = SND_CAPTURE_VOLUME_0DB / 72; // not good, needs TLV
+	return 0;
+}
+static const DECLARE_TLV_DB_LINEAR(db_scale_linear, TLV_DB_GAIN_MUTE, 1204);
+
+static int snd_capture_master_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	int index = ucontrol->id.index;
+
+	ucontrol->value.integer.value[0] = elem->cache_val[index];
+	ucontrol->value.integer.value[1] = elem->cache_val[index]; // TODO
+
+	return 0;
+}
+static int snd_capture_master_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	int val, err;
+	int index = ucontrol->id.index;
+
+	val = ucontrol->value.integer.value[0];
+
+	err = 1;
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set channel, err:%d\n", err);
+	}
+
+	return err > 0 ? 1 : 0;
+}
+static int snd_capture_master_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->count = 2;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.max = 0x800000;
+	uinfo->value.integer.min = 0x000000;
+	//uinfo->value.integer.step = SND_CAPTURE_VOLUME_0DB / 72; // not good, needs TLV
+	return 0;
+}
+
+static const struct snd_kcontrol_new snd_capture_master_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 2,
+	.info = snd_capture_master_info,
+	.get  = snd_capture_master_get,
+	.put  = snd_capture_master_put,
+	.private_value = 0x70001,
+	.tlv = { .p = db_scale_linear },
+};
+
+static const struct snd_kcontrol_new snd_capture_volume_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 16,
+	.info = snd_capture_volume_info,
+	.get  = snd_capture_volume_get,
+	.put  = snd_capture_volume_put,
+	.private_value = 0x60008,
+	.tlv = { .p = db_scale_linear },
+};
+static const struct snd_kcontrol_new snd_capture_reverb_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 16,
+	.info = snd_capture_volume_info,
+	.get  = snd_capture_volume_get,
+	.put  = snd_capture_volume_put,
+	.private_value = 0x6000e,
+	.tlv = { .p = db_scale_linear },
+};
+static const struct snd_kcontrol_new snd_capture_return_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 1,
+	.info = snd_capture_volume_info,
+	.get  = snd_capture_volume_get,
+	.put  = snd_capture_volume_put,
+	.private_value = 0x80007,
+	.tlv = { .p = db_scale_linear },
+};
+static const struct snd_kcontrol_new snd_capture_daw_volume_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 10,
+	.info = snd_capture_volume_info,
+	.get  = snd_capture_volume_get,
+	.put  = snd_capture_volume_put,
+	.private_value = 0x70008,
+	.tlv = { .p = db_scale_linear },
+};
+
+static int snd_capture_byte_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	int index = ucontrol->id.index;
+
+	ucontrol->value.integer.value[0] = elem->cache_val[index];
+
+	return 0;
+}
+
+static int snd_capture_byte_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_elem_info *elem = kcontrol->private_data;
+	struct snd_usb_audio *chip = elem->head.mixer->chip;
+	int val, err;
+	int index = ucontrol->id.index;
+
+	val = ucontrol->value.integer.value[0];
+
+	err = 1;
+	if (err > 0) {
+		elem->cached |= 1 << index;
+		elem->cache_val[index] = val;
+	} else {
+		usb_audio_dbg(chip, "Failed to set channel, err:%d\n", err);
+	}
+
+	return err > 0 ? 1 : 0;
+}
+
+static int snd_capture_reverb_time_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->count = 1;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.max = 50;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+static const struct snd_kcontrol_new snd_capture_reverb_time_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+	.count = 1,
+	.info = snd_capture_reverb_time_info,
+	.get  = snd_capture_byte_get,
+	.put  = snd_capture_byte_put,
+	.private_value = 0x40102,
+};
+
+/*
+static int snd_capture_sens_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->count = 1;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->value.integer.max = 116;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+static const DECLARE_TLV_DB_MINMAX(sens_scale, 0, 5800); // 0 .. 116 means +0 dB .. 58 dB in 0.5 dB steps
+static const struct snd_kcontrol_new snd_capture_sens_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ),
+	.count = 12,
+	.info = snd_capture_sens_info,
+	.get  = snd_capture_byte_get,
+	.put  = snd_capture_byte_put,
+	.private_value = 0x50004,
+	.tlv = { .p = sens_scale },
+};
+*/
+
+#define DECLARE_CAPTURE_DB_KNOB(addr, name, minimum, maximum) \
+static int snd_capture_##name##_info(struct snd_kcontrol *kcontrol, \
+	struct snd_ctl_elem_info *uinfo) \
+{ \
+	uinfo->count = 1; \
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER; \
+	uinfo->value.integer.min = 0; \
+	uinfo->value.integer.max = (maximum - minimum) / 100; \
+	uinfo->value.integer.step = 1; \
+	return 0; \
+} \
+static const DECLARE_TLV_DB_MINMAX(name##_scale, minimum, maximum); \
+static const struct snd_kcontrol_new snd_capture_##name##_ctl = { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE | \
+	           SNDRV_CTL_ELEM_ACCESS_TLV_READ), \
+	.count = 12, \
+	.info = snd_capture_##name##_info, \
+	.get  = snd_capture_byte_get, \
+	.put  = snd_capture_byte_put, \
+	.private_value = addr, \
+	.tlv = { .p = name##_scale }, \
+};
+
+DECLARE_CAPTURE_DB_KNOB(0x50004, sens     ,     0,  5800)
+DECLARE_CAPTURE_DB_KNOB(0x50007, gate     , -7000, -2000);
+DECLARE_CAPTURE_DB_KNOB(0x5000a, threshold, -4000,     0);
+DECLARE_CAPTURE_DB_KNOB(0x5000c, gain     , -4000,  4000);
+
+#define DECLARE_CAPTURE_ENUM(addr, name, c, ...) \
+static const char *name##_names[] = (const char *[]){ \
+	__VA_ARGS__ \
+}; \
+static int snd_capture_##name##_info(struct snd_kcontrol *kcontrol, \
+	struct snd_ctl_elem_info *uinfo) \
+{ \
+	return snd_ctl_enum_info(uinfo, 1, (sizeof(name##_names)/sizeof(char*)), name##_names); \
+} \
+static const struct snd_kcontrol_new snd_capture_##name##_ctl = { \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.count = c, \
+	.info = snd_capture_##name##_info, \
+	.get = snd_capture_byte_get, \
+	.put = snd_capture_byte_put, \
+	.private_value = addr, \
+}
+
+DECLARE_CAPTURE_ENUM(0x5000b, ratio, 12,
+	"1", "1.12", "1.25", "1.4", "1.6", "1.8",
+	"2", "2.5", "3.2", "4", "5.6", "8", "16", "inf",
+);
+DECLARE_CAPTURE_ENUM(0x50008, attack, 12,
+	 "0.0",  "0.1",  "0.2",  "0.3",  "0.4",  "0.5",  "0.6",  "0.7",  "0.8",  "0.9",
+	 "1.0",  "1.1",  "1.2",  "1.3",  "1.4",  "1.5",  "1.6",  "1.7",  "1.8",  "1.9",
+	 "2.0",  "2.1",  "2.2",  "2.4",  "2.5",  "2.7",  "2.8",  "3.0",  "3.2",  "3.3",  "3.6",  "3.8",
+	 "4.0",  "4.2",  "4.5",  "4.7",  "5.0",  "5.3",  "5.6",  "6.0",  "6.3",  "6.7",  "7.1",  "7.5",
+	 "8.0",  "8.4",  "9.0",  "9.4", "10.0", "10.6", "11.2", "12.0", "12.5", "13.3", "14.0", "15.0",
+	"16.0", "17.0", "18.0", "19.0", "20.0", "21.0", "22.4", "23.7", "25.0", "26.6", "28.0", "30.0",
+	"31.5", "33.5", "35.5", "37.6", "40.0", "42.2", "45.0", "47.3", "50.0", "53.0", "56.0", "60.0",
+	"63.0", "67.0", "71.0", "75.0", "80.0", "84.0", "90.0", "94.4", "100",  "106",  "112",  "120",
+	"125",  "133",  "140",  "150",  "160",  "170",  "180",  "190",  "200",  "210",  "224",  "237",
+	"250",  "266",  "280",  "300",  "315",  "335",  "355",  "376",  "400",  "422",  "450",  "473",
+	"500",  "530",  "560",  "600",  "630",  "670",  "710",  "750",  "800",
+);
+DECLARE_CAPTURE_ENUM(0x50009, release, 12,
+	   "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",
+	  "10",   "11",   "12",   "13",   "14",   "15",   "16",   "17",   "18",   "19",
+	  "20",   "21",   "22",   "24",   "25",   "27",   "28",   "30",   "32",   "33",   "36",   "38",
+	  "40",   "42",   "45",   "47",   "50",   "53",   "56",   "60",   "63",   "67",   "71",   "75",
+	  "80",   "84",   "90",   "94",  "100",  "106",  "112",  "120",  "125",  "133",  "140",  "150",
+	 "160",  "170",  "180",  "190",  "200",  "210",  "224",  "237",  "250",  "266",  "280",  "300",
+	 "315",  "335",  "355",  "376",  "400",  "422",  "450",  "473",  "500",  "530",  "560",  "600",
+	 "630",  "670",  "710",  "750",  "800",  "840",  "900",  "944", "1000", "1060", "1120", "1200",
+	"1250", "1330", "1400", "1500", "1600", "1700", "1800", "1900", "2000", "2100", "2240", "2370",
+	"2500", "2660", "2800", "3000", "3150", "3350", "3550", "3760", "4000", "4220", "4500", "4730",
+	"5000", "5300", "5600", "6000", "6300", "6700", "7100", "7500", "8000",
+);
+DECLARE_CAPTURE_ENUM(0x5000d, knee, 12,
+	"HARD", "SOFT1", "SOFT2", "SOFT3", "SOFT4", "SOFT5", "SOFT6", "SOFT7", "SOFT8", "SOFT9",
+);
+DECLARE_CAPTURE_ENUM(0x51001, attenuation, 4, "-20","-10","+4"); // consider dB
+DECLARE_CAPTURE_ENUM(0x40000, reverb_type, 1,
+	"OFF", "ECHO", "ROOM", "SMALL HALL", "LARGE HALL", "PLATE",
+);
+DECLARE_CAPTURE_ENUM(0x40101, pre_delay, 1,
+	"0.0", "0.1", "0.2", "0.4", "0.8", "1.6", "3.2", "6.4", "10", "20", "40", "80", "160",
+);
+DECLARE_CAPTURE_ENUM(0x00102, auto_sens, 1, "OFF", "ON", "CANCEL");
+
+#define SND_CAPTURE_PAN_CENTER 0x4000
+#define SND_CAPTURE_VOLUME_0DB 0x200000
+
+static const DECLARE_CAPTURE_SWITCH(0x50005, preamp_stereo, 6);
+static const DECLARE_CAPTURE_SWITCH(0x51000, line_stereo, 2);
+static const DECLARE_CAPTURE_SWITCH(0x80000, master_direct_stereo, 1);
+static const DECLARE_CAPTURE_SWITCH(0x8000d, master_link, 1);
+static const DECLARE_CAPTURE_SWITCH(0x90000, master_daw_stereo, 1);
+
+#define SND_CAPTURE_NEW_CTL(addr, ctlname, desc, n, type, default_val) \
+{ \
+	sprintf(name, desc); \
+	err = add_new_ctl(mixer, \
+		&snd_capture_##ctlname##_ctl, \
+		addr, type, n, \
+		name, NULL, \
+		false, &elem); \
+	if (err < 0) { \
+		usb_audio_dbg(mixer->chip, \
+			"Failed to create route control, err:%d\n", \
+			err); \
+		return err; \
+	} \
+	for (i = 0; i < n; i++) \
+		elem->cache_val[i] = default_val; \
+	elem->cached = 0xff; \
+}
+#define SND_CAPTURE_NEW_MON_CTL(addr, ctlname, desc, n, type, default_val) \
+{ \
+	sprintf(name, desc, mon); \
+	err = add_new_ctl(mixer, \
+		&snd_capture_##ctlname##_ctl, \
+		addr, type, n, \
+		name, NULL, \
+		false, &elem); \
+	if (err < 0) { \
+		usb_audio_dbg(mixer->chip, \
+			"Failed to create route control, err:%d\n", \
+			err); \
+		return err; \
+	} \
+	for (i = 0; i < n; i++) \
+		elem->cache_val[i] = default_val; \
+	elem->cached = 0xff; \
+}
+
+int snd_capture_controls_create(struct usb_mixer_interface *mixer)
+{
+	int i,m,n;
+	char mon;
+	int err;
+	struct usb_mixer_elem_info *elem;
+	char name[64];
+	/*
+	struct snd_capture_comp_store *comp_store;
+	struct snd_capture_meter_store *meter_store;
+	struct snd_capture_eq_store *eq_store;
+	*/
+
+	/* just check for non-MIDI interface */
+	pr_info("Hello from capture controls bInterfaceNumber=%d", mixer->hostif->desc.bInterfaceNumber);
+
+	SND_CAPTURE_NEW_CTL(0x30000, patchbay     , "Output Route"           ,  5, USB_MIXER_U8, i);
+	SND_CAPTURE_NEW_CTL(0x50005, preamp_stereo, "Preamp Stereo Switch"   ,  6, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50000, 48           , "Preamp +48"             , 12, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50001, locut        , "Preamp Lo-Cut"          , 12, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50002, phase        , "Preamp Phase"           , 12, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50003, hiz          , "Preamp Hi-Z"            , 12, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50004, sens         , "Preamp Sens Volume"     , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x50006, bypass       , "Preamp Bypass"          , 12, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x50007, gate         , "Preamp Gate Volume"     , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x50008, attack       , "Preamp Attack"          , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x50009, release      , "Preamp Release"         , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x5000a, threshold    , "Preamp Threshold Volume", 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x5000b, ratio        , "Preamp Ratio"           , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x5000c, gain         , "Preamp Gain Volume"     , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x5000d, knee         , "Preamp Knee"            , 12, USB_MIXER_U8, 0);
+	SND_CAPTURE_NEW_CTL(0x51000, line_stereo  , "Line Stereo Switch"     ,  2, USB_MIXER_BOOLEAN, 0);
+	SND_CAPTURE_NEW_CTL(0x51001, attenuation  , "Line Attenuation"       ,  5, USB_MIXER_U8, 0);
+
+	for (mon = 'A'; mon <= 'D'; mon++) {
+		m = (mon - 'A') * 0x1000;
+
+		SND_CAPTURE_NEW_MON_CTL(0x60000 + m, stereo        , "Direct Monitor %c Stereo Switch",  8, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x60002 + m, solo          , "Direct Monitor %c Solo Switch"  , 16, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x60003 + m, mute          , "Direct Monitor %c Mute Switch"  , 16, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x60004 + m, pan           , "Direct Monitor %c Pan"          , 16, USB_MIXER_U16, SND_CAPTURE_PAN_CENTER);
+		SND_CAPTURE_NEW_MON_CTL(0x60008 + m, volume        , "Direct Monitor %c Volume"       , 16, USB_MIXER_U32, SND_CAPTURE_VOLUME_0DB);
+		if (mon == 'A') {
+			SND_CAPTURE_NEW_MON_CTL(0x60008 + m, reverb    , "Direct Monitor %c Reverb Volume", 16, USB_MIXER_U32, 0x000000);
+		}
+
+		SND_CAPTURE_NEW_MON_CTL(0x70000 + m, daw_stereo        , "DAW %c Stereo Switch"          ,  5, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x70002 + m, daw_solo          , "DAW %c Solo Switch"            , 10, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x70003 + m, daw_mute          , "DAW %c Mute Switch"            , 10, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x70004 + m, daw_pan           , "DAW %c Pan"                    , 10, USB_MIXER_U16, SND_CAPTURE_PAN_CENTER);
+		SND_CAPTURE_NEW_MON_CTL(0x70008 + m, daw_volume        , "DAW %c Volume"                 , 10, USB_MIXER_U32, SND_CAPTURE_VOLUME_0DB);
+		if (mon == 'A') {
+			SND_CAPTURE_NEW_MON_CTL(0x80007 + m, return        , "Master %c Reverb Return Volume",  1, USB_MIXER_U32, SND_CAPTURE_VOLUME_0DB);
+		}
+
+		SND_CAPTURE_NEW_MON_CTL(0x8000d + m, master_link         , "Master %c Link Switch"                 , 16, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x80000 + m, master_direct_stereo, "Master %c Direct Monitor Stereo Switch", 16, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x80001 + m, master              , "Master %c Direct Monitor Volume"       , 16, USB_MIXER_U32, SND_CAPTURE_VOLUME_0DB);
+		SND_CAPTURE_NEW_MON_CTL(0x90000 + m, master_daw_stereo   , "Master %c DAW Stereo Switch"           , 16, USB_MIXER_BOOLEAN, 0);
+		SND_CAPTURE_NEW_MON_CTL(0x90001 + m, master              , "Master %c DAW Volume"                  , 16, USB_MIXER_U32, SND_CAPTURE_VOLUME_0DB);
+	}
+
+	SND_CAPTURE_NEW_CTL(0x40000, reverb_type  , "Reverb Type"            ,  1, USB_MIXER_U8, 1);
+
+	for (m = 0x100; m <= 0x500; m+=0x100) {
+		n = 1;
+		sprintf(name, "Reverb %s Pre Delay", reverb_type_names[m/0x100]);
+		err = add_new_ctl(mixer,
+			&snd_capture_pre_delay_ctl,
+			0x40001 + m, USB_MIXER_U8, n,
+			name, NULL,
+			false, &elem);
+		if (err < 0)
+			return err;
+		for (i = 0; i < n; i++)
+			elem->cache_val[i] = 0;
+		elem->cached = 1;
+
+		sprintf(name, "Reverb %s Time", reverb_type_names[m/0x100]);
+		err = add_new_ctl(mixer,
+			&snd_capture_reverb_time_ctl,
+			0x40002 + m, USB_MIXER_U8, n,
+			name, NULL,
+			false, &elem);
+		if (err < 0)
+			return err;
+		for (i = 0; i < n; i++)
+			elem->cache_val[i] = 1;
+		elem->cached = 1;
+	}
+
+#if 0
+		/* create meters store */
+		meter_store = snd_capture_create_meter_store();
+		if (!meter_store)
+			return -ENOMEM;
+
+		/* meter function 'get' must access to compressor store
+		 * so place a reference here
+		 */
+		meter_store->comp_store = comp_store;
+		err = add_new_ctl(mixer, &snd_capture_meter_ctl,
+			SND_US16X08_ID_METER, USB_MIXER_U16, 0, "Level Meter",
+			meter_store, true, NULL);
+		if (err < 0)
+			return err;
+	}
+#endif
+
+	return 0;
+}
+
diff --git a/sound/usb/mixer_capture.h b/sound/usb/mixer_capture.h
new file mode 100644
index 000000000000..8b41d05fded9
--- /dev/null
+++ b/sound/usb/mixer_capture.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __USB_MIXER_CAPTURE_H
+#define __USB_MIXER_CAPTURE_H
+
+int snd_capture_controls_create(struct usb_mixer_interface *mixer);
+#endif /* __USB_MIXER_CAPTURE_H */
+
diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c
index d35cf54cab33..6415b59839a3 100644
--- a/sound/usb/mixer_quirks.c
+++ b/sound/usb/mixer_quirks.c
@@ -30,6 +30,7 @@
 
 #include "usbaudio.h"
 #include "mixer.h"
+#include "mixer_capture.h"
 #include "mixer_quirks.h"
 #include "mixer_scarlett.h"
 #include "mixer_scarlett_gen2.h"
@@ -3159,6 +3160,11 @@ int snd_usb_mixer_apply_create_quirk(struct usb_mixer_interface *mixer)
 		return err;
 
 	switch (mixer->chip->usb_id) {
+	case USB_ID(0x0582, 0x0120): /* Roland OCTA-CAPTURE */
+	case USB_ID(0x0582, 0x0160): /* Roland STUDIO-CAPTURE */
+		err = snd_capture_controls_create(mixer);
+		break;
+
 	/* Tascam US-16x08 */
 	case USB_ID(0x0644, 0x8047):
 		err = snd_us16x08_controls_create(mixer);
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 968d90caeefa..c48bcd8e8988 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -394,6 +394,8 @@ static int create_autodetect_quirks(struct snd_usb_audio *chip,
 	int probed_ifnum = get_iface_desc(iface->altsetting)->bInterfaceNumber;
 	int ifcount, ifnum, err;
 
+	pr_info("create autodetect quirks");
+
 	err = create_autodetect_quirk(chip, iface, driver);
 	if (err < 0)
 		return err;
